{
  "hash": "c65264d1624e96c160de64df836ff506",
  "result": {
    "markdown": "---\ntitle: 'Part 2: Processing data in GRASS'\nauthor: VerÃ³nica Andreo\ndate: '`r Sys.Date()`'\nformat:\n  html:\n    code-tools: true\n    code-copy: true\n    code-fold: false\nexecute:\n  eval: false\n  cache: true\n---\n\nIn this notebook we'll go through the processing of MODIS LST daily time series\ndata to derive relevant predictor variables for modeling the distribution of\n*Aedes albopictus* in Northern Italy. Furthermore, we'll show how to obtain and\nprocess occurrence data and background points.\n\nLet's first go through some temporal concepts within GRASS GIS...\n\n\n## The TGRASS framework\n\nGRASS GIS was the first FOSS GIS that incorporated capabilities to \n*manage, analyze, process and visualize spatio-temporal data*, as well as \nthe temporal relationships among time series.\n\n- TGRASS is fully **based on metadata** and does not duplicate any dataset\n- **Snapshot** approach, i.e., adds time stamps to maps\n- A collection of time stamped maps (snapshots) of the same variable are called **space-time datasets** or STDS\n- Maps in a STDS can have different spatial and temporal extents\n- Space-time datasets can be composed of raster, raster 3D or vector maps, and so\nwe call them:\n  - Space time raster datasets (**STRDS**)\n  - Space time 3D raster datasets (**STR3DS**)\n  - Space time vector datasets (**STVDS**)\n\n\n## Temporal modules\n\nGRASS temporal modules are named and organized following GRASS core naming\nscheme. In this way, we have:\n\n- **t.\\***: General modules to handle STDS of all types\n- **t.rast.\\***: Modules that deal with STRDS\n- **t.rast3d.\\***: Modules that deal with STR3DS\n- **t.vect.\\***: Modules that deal with STVDS\n\n\n### Other TGRASS notions\n\n- Time can be defined as **intervals** (start and end time) or **instances** \n(only start time)\n- Time can be **absolute** (e.g., 2017-04-06 22:39:49) or **relative** \n(e.g., 4 years, 90 days)\n- **Granularity** is the greatest common divisor of the temporal extents \n(and possible gaps) of all maps in the space-time cube\n\n![](https://grass.osgeo.org/grass-stable/manuals/timeline_2D.jpg){width=\"50%\" fig-align=\"center\"}\n\n- **Topology** refers to temporal relations between time intervals in a STDS.\n\n![](assets/img/studio/temp_relation.png){width=\"35%\" fig-align=\"center\"}\n\n### TGRASS framework and workflow\n\n![](assets/img/studio/tgrass_flowchart.png){width=\"70%\" fig-align=\"center\"}\n\n## Hands-on\n\nSo let's start... We begin by setting variables, checking GRASS installation and initializing GRASS GIS\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport os\n\n# Data directory\nhomedir = os.path.join(os.path.expanduser('~'), \"grass_ncsu_2023\")\n\n# GRASS GIS database variables\n#grassbin = \"grassdev\"\ngrassbin = \"grass\"\ngrassdata = os.path.join(homedir, \"grassdata\")\nlocation = \"eu_laea\"\nmapset = \"italy_LST_daily\"\n\n# Create directories if not already existing\nos.makedirs(grassdata, exist_ok=True)\n```\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# Check the GRASS GIS installation\nimport subprocess\nprint(subprocess.check_output([grassbin, \"--config\", \"version\"], text=True))\n```\n:::\n\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# Ask GRASS GIS where its Python packages are \nimport sys\nsys.path.append(\n    subprocess.check_output([grassbin, \"--config\", \"python_path\"], text=True).strip()\n)\n```\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# Import the GRASS GIS packages we need\nimport grass.script as gs\nimport grass.jupyter as gj\n\n# Start the GRASS GIS Session\nsession = gj.init(grassdata, location, mapset)\n```\n:::\n\n\n### Explore data in the mapset\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n# List vector elements\ngs.list_grouped(type=\"vector\")['italy_LST_daily']\n```\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# Display vector map\nit_map = gj.Map(width=500, use_region=True)\nit_map.d_vect(map=\"italy_borders_0\")\nit_map.show()\n```\n:::\n\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n# List raster elements\ngs.list_grouped(type=\"raster\", pattern=\"lst*\")['italy_LST_daily']\n```\n:::\n\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n# Display raster map with interactive class\nlst_map = gj.InteractiveMap(width = 500, use_region=True, tiles=\"OpenStreetMap\")\nlst_map.add_raster(\"lst_2014.005_avg\")\nlst_map.add_layer_control(position = \"bottomright\")\nlst_map.show()\n```\n:::\n\n\n## SDM workflow\n\nIn this part of the Studio we'll be addressing the left part of the SDM workflow, occurrence and background data and predictors:\n\n![](assets/img/lecture/workflow_sdm_other.png)\n\n### Importing species records\n\nWe will use occurrence data already downloaded and cleaned. We need to import it into GRASS GIS first.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n# Import mosquito records\ngs.run_command(\"v.import\",\n               input=os.path.join(homedir,\"aedes_albopictus.gpkg\"),\n               output=\"aedes_albopictus\")\n```\n:::\n\n\nLet's add the occurrence points over the previous interactive map\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\n# Display raster map with interactive class\nlst_map = gj.InteractiveMap(width = 500, use_region=True, tiles=\"OpenStreetMap\")\nlst_map.add_raster(\"lst_2014.005_avg\")\nlst_map.add_vector(\"aedes_albopictus\")\nlst_map.add_layer_control(position = \"bottomright\")\nlst_map.show()\n```\n:::\n\n\nYou can also get the mosquito occurrences (or any other species or taxa) directly from [GBIF](https://www.gbif.org/) into GRASS\nby means of [v.in.pygbif](https://grass.osgeo.org/grass-stable/manuals/addons/v.in.pygbif.html) as follows: \n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n# Set computational region\n# region = gs.parse_command(\"g.region\", raster=\"lst_2014.001_avg\", flags=\"g\")\n# region\n```\n:::\n\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\n# Install extension (requires pygbif: pip install pygbif)\n# gs.run_command(\"g.extension\",\n#                extension=\"v.in.pygbif\")\n```\n:::\n\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\n# Import data from GBIF\n# gs.run_command(\"v.in.pygbif\", \n#                output=\"aedes_albopictus\",\n#                taxa=\"Aedes albopictus\",\n#                date_from=\"2014-01-01\",\n#                date_to=\"2018-12-31\")\n```\n:::\n\n\n### Creating random background points\n\nThe algorithm MaxEnt that we will use in the next part of this session requires not only the locations of known occurrences, but also information on the rest of the environment available. These are not absences but background data, we actually do not know if the species is there or not, but we need it to compare with the features of the places where the species does occur. \n\nTo avoid getting background points exactly where occurrences are, we'll create buffers around them. Then, we need to ensure that background points are only over land within our computational region. In order to do that, we'll create a mask over land and we'll overlay the buffers with the mask. Can you guess what the ooutput will be?\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\n# Create buffer around Aedes albopictus records\ngs.run_command(\"v.buffer\",\n               input=\"aedes_albopictus\",\n               output=\"aedes_buffer\",\n               distance=2000)\n```\n:::\n\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\n# Set computational region\nregion = gs.parse_command(\"g.region\", raster=\"lst_2014.001_avg\", flags=\"g\")\nregion\n```\n:::\n\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n# Create a vector mask to limit background points\nexpression=\"MASK = if(lst_2014.001_avg, 1, null())\"\ngs.raster.mapcalc(exp=expression)\n\ngs.run_command(\"r.to.vect\", \n               input=\"MASK\",\n               output=\"vect_mask\",\n               type=\"area\")\n```\n:::\n\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\n# Subtract buffers from vector mask\ngs.run_command(\"v.overlay\",\n               ainput=\"vect_mask\",\n               binput=\"aedes_buffer\",\n               operator=\"xor\",\n               output=\"mask_bg\")\n```\n:::\n\n\nLet's display the result\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\n# Display raster map with interactive class\nmask_map = gj.InteractiveMap(width = 500, use_region=True, tiles=\"OpenStreetMap\")\nmask_map.add_vector(\"mask_bg\")\nmask_map.add_layer_control(position = \"bottomright\")\nmask_map.show()\n```\n:::\n\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\n# Generate random background points\ngs.run_command(\"v.random\",\n               output=\"background_points\",\n               npoints=1000,\n               restrict=\"mask_bg\",\n               seed=3749)\n```\n:::\n\n\nLet's now display occurence and background points together over an LST map\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\n# Display vector map\npb_map = gj.Map(width=500, use_region=True)\npb_map.d_rast(map=\"lst_2014.005_avg\")\npb_map.d_vect(map=\"italy_borders_0\", type=\"boundary\")\npb_map.d_vect(map=\"background_points\")\npb_map.d_vect(map=\"aedes_albopictus\", icon=\"basic/diamond\", fill_color=\"red\", size=8)\npb_map.show()\n```\n:::\n\n\n### Create daily LST STRDS\n\nNow we'll start processing the raster data to derive potentially relevant predictors to include in the model. Our data consists of a time series of daily LST averages. We'll use the GRASS temporal framework for this and the first step is to create the time series object and register maps in it. See [t.create](https://grass.osgeo.org/grass-stable/manuals/t.create.html) and [t.register](https://grass.osgeo.org/grass-stable/manuals/t.register.html) for further details.\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\n# Create time series \ngs.run_command(\"t.create\",\n               type=\"strds\",\n               temporaltype=\"absolute\",\n               output=\"lst_daily\",\n               title=\"Average Daily LST\",\n               description=\"Average daily LST in degree C - 2014-2018\")\n```\n:::\n\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\n# Check it is created\ngs.run_command(\"t.list\",\n              type=\"strds\")\n```\n:::\n\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\n# Get list of maps \nmap_list=gs.list_grouped(type=\"raster\", pattern=\"lst_201*\")['italy_LST_daily']\nmap_list\n```\n:::\n\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\n# Register maps in strds  \ngs.run_command(\"t.register\", \n               input=\"lst_daily\",\n               maps=map_list,\n               increment=\"1 days\",\n               start=\"2014-01-01\", \n               flags=\"i\")\n```\n:::\n\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\n# Get info about the strds\ngs.run_command(\"t.info\",\n               input=\"lst_daily\")\n```\n:::\n\n\n### Generate environmental variables from LST STRDS\n\n#### Long term monthly avg, min and max LST - Climatologies\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\n# January average LST\ngs.run_command(\"t.rast.series\",\n               input=\"lst_daily\",\n               method=\"average\",\n               where=\"strftime('%m', start_time)='01'\",\n               output=\"lst_average_jan\")\n```\n:::\n\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\ngs.raster_info(\"lst_average_jan\")\n```\n:::\n\n\nIf we want to estimate climatologies for all months, let's try first to get the list of maps that will be the input for [t.rast.series](https://grass.osgeo.org/grass-stable/manuals/t.rast.series.html), for that we'll test the condition in [t.rast.list](https://grass.osgeo.org/grass-stable/manuals/t.rast.list.html) first.\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\n# Define list of months as required\nmonths=['{0:02d}'.format(m) for m in range(1,13)]\n\nfor m in months:\n    gs.run_command(\"t.rast.list\",\n                   input=\"lst_daily\",\n                   where=f\"strftime('%m', start_time)='{m}'\")\n```\n:::\n\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\n# Now we estimate the climatologies for all months and methods\nmonths=['{0:02d}'.format(m) for m in range(1,13)]\nmethods=[\"average\",\"minimum\",\"maximum\"]\n\nfor m in months:\n    for me in methods:\n        gs.run_command(\"t.rast.series\", \n                       input=\"lst_daily\",\n                       method=me,\n                       where=f\"strftime('%m', start_time)='{m}'\",\n                       output=\"lst_{}_{}\".format(me,m))\n```\n:::\n\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\n# List newly created maps\ngs.list_grouped(type=\"raster\", pattern=\"*{average,minimum,maximum}*\")['italy_LST_daily']\n```\n:::\n\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\n# Remove lst_average_jan\ngs.run_command(\"g.remove\", type=\"raster\", name=\"lst_average_jan\", flags=\"f\")\n```\n:::\n\n\n#### Bioclimatic variables\n\nPerhaps you have heard of [Worldclim](https://www.worldclim.org/) or [CHELSA](https://chelsa-climate.org/) bioclimatic variables? Well, this are 19 variables that represent potentially limiting conditions for species. They derive from the combination of temperature and precipitation long term averages. As we do not have precipitation data in this exercise, we'll only estimate the bioclimatic variables that include temperature. See [r.bioclim](https://grass.osgeo.org/grass-stable/manuals/addons/r.bioclim.html) manual for further details.\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\n# Install extension\ngs.run_command(\"g.extension\",\n               extension=\"r.bioclim\")\n```\n:::\n\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\n# Get lists of maps needed\ntmin=gs.list_grouped(type=\"raster\", pattern=\"lst_minimum_??\")['italy_LST_daily']\ntmax=gs.list_grouped(type=\"raster\", pattern=\"lst_maximum_??\")['italy_LST_daily']\ntavg=gs.list_grouped(type=\"raster\", pattern=\"lst_average_??\")['italy_LST_daily']\n\nprint(tmin,tmax,tavg)\n```\n:::\n\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\n# Estimate temperature related bioclimatic variables\ngs.run_command(\"r.bioclim\", \n               tmin=tmin, \n               tmax=tmax,\n               tavg=tavg, \n               output=\"worldclim_\") \n```\n:::\n\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\n# List output maps\ngs.list_grouped(type=\"raster\", pattern=\"worldclim*\")['italy_LST_daily']\n```\n:::\n\n\nLet's have a look at some of the maps we just created\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\n# Display raster map with interactive class\nbio_map = gj.InteractiveMap(width = 500, use_region=True, tiles=\"OpenStreetMap\")\nbio_map.add_raster(\"worldclim_bio01\")\nbio_map.add_raster(\"worldclim_bio02\")\nbio_map.add_layer_control(position = \"bottomright\")\nbio_map.show()\n```\n:::\n\n\n#### Spring warming\n\nWe define spring warming as the velocity with which temperature increases from winter into spring and we calculate it as `slope(daily Tmean february-march-april)`. We will use [t.rast.aggregate](https://grass.osgeo.org/grass-stable/manuals/t.rast.aggregate.html).\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\n# Define list of months\nmonths=['{0:02d}'.format(m) for m in range(2,5)]\n```\n:::\n\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\n# Annual spring warming\ngs.run_command(\"t.rast.aggregate\",\n               input=\"lst_daily\",\n               output=\"annual_spring_warming\",\n               basename=\"spring_warming\",\n               suffix=\"gran\",\n               method=\"slope\",\n               granularity=\"1 years\",\n               where=f\"strftime('%m',start_time)='{months[0]}' or strftime('%m',start_time)='{months[1]}' or strftime('%m', start_time)='{months[2]}'\")\n```\n:::\n\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\n# Check raster maps in the STRDS\ngs.run_command(\"t.rast.list\", input=\"annual_spring_warming\")\n```\n:::\n\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\n# Average spring warming\ngs.run_command(\"t.rast.series\",\n               input=\"annual_spring_warming\",\n               output=\"avg_spring_warming\",\n               method=\"average\")\n```\n:::\n\n\n::: {.cell execution_count=42}\n``` {.python .cell-code}\n# Display raster map with interactive class\nauc_map = gj.InteractiveMap(width = 500, use_region=True, tiles=\"OpenStreetMap\")\nauc_map.add_raster(\"avg_spring_warming\")\nauc_map.add_layer_control(position = \"bottomright\")\nauc_map.show()\n```\n:::\n\n\n#### Autumnal cooling\n\nWe define autumnal cooling as the velocity with which temperature decreases from summer into fall and we calculate it as `slope(daily Tmean august-september-october)`.\n\n::: {.cell execution_count=43}\n``` {.python .cell-code}\n# Define list of months\nmonths=['{0:02d}'.format(m) for m in range(8,11)]\n```\n:::\n\n\n::: {.cell execution_count=44}\n``` {.python .cell-code}\n# Annual autumnal cooling\ngs.run_command(\"t.rast.aggregate\",\n               input=\"lst_daily\",\n               output=\"annual_autumnal_cooling\",\n               basename=\"autumnal_cooling\",\n               suffix=\"gran\",\n               method=\"slope\",\n               granularity=\"1 years\",\n               where=f\"strftime('%m',start_time)='{months[0]}' or strftime('%m',start_time)='{months[1]}' or strftime('%m', start_time)='{months[2]}'\")\n```\n:::\n\n\n::: {.cell execution_count=45}\n``` {.python .cell-code}\n# Check raster maps in the STRDS\ngs.run_command(\"t.rast.list\", input=\"annual_autumnal_cooling\")\n```\n:::\n\n\n::: {.cell execution_count=46}\n``` {.python .cell-code}\n# Average autumnal cooling\ngs.run_command(\"t.rast.series\",\n               input=\"annual_autumnal_cooling\",\n               output=\"avg_autumnal_cooling\",\n               method=\"average\")\n```\n:::\n\n\n::: {.cell execution_count=47}\n``` {.python .cell-code}\n# Display raster map with interactive class\nspw_map = gj.InteractiveMap(width = 500, use_region=True, tiles=\"OpenStreetMap\")\nspw_map.add_raster(\"avg_autumnal_cooling\")\nspw_map.add_layer_control(position = \"bottomright\")\nspw_map.show()\n```\n:::\n\n\n#### Number of days with LSTmean >= 20 and <= 30\n\n::: {.cell execution_count=48}\n``` {.python .cell-code}\n# Keep only pixels meeting the condition\nexpression=\"tmean_higher20_lower30 = if(lst_daily >= 20.0 && lst_daily <= 30.0, 1, null())\"\n\ngs.run_command(\"t.rast.algebra\",\n               expression=expression, \n               basename=\"tmean_higher20_lower30\",\n               suffix=\"gran\",\n               nproc=7, \n               flags=\"n\")\n```\n:::\n\n\n::: {.cell execution_count=49}\n``` {.python .cell-code}\n# Count how many times per year the condition is met\ngs.run_command(\"t.rast.aggregate\",\n               input=\"tmean_higher20_lower30\", \n               output=\"count_tmean_higher20_lower30\",\n               basename=\"tmean_higher20_lower30\",\n               suffix=\"gran\",\n               method=\"count\",\n               granularity=\"1 years\")\n```\n:::\n\n\n::: {.cell execution_count=50}\n``` {.python .cell-code}\n# Check raster maps in the STRDS\ngs.run_command(\"t.rast.list\", \n               input=\"count_tmean_higher20_lower30\", \n               columns=\"name,start_time,min,max\")\n```\n:::\n\n\n::: {.cell execution_count=51}\n``` {.python .cell-code}\n# Average number of days with LSTmean >= 20 and <= 30\ngs.run_command(\"t.rast.series\",\n               input=\"count_tmean_higher20_lower30\",\n               output=\"avg_count_tmean_higher20_lower30\",\n               method=\"average\")\n```\n:::\n\n\n::: {.cell execution_count=52}\n``` {.python .cell-code}\n# Display raster map with interactive class\nh20_map = gj.InteractiveMap(width = 500, use_region=True, tiles=\"OpenStreetMap\")\nh20_map.add_raster(\"avg_count_tmean_higher20_lower30\")\nh20_map.add_layer_control(position = \"bottomright\")\nh20_map.show()\n```\n:::\n\n\nSee [t.rast.algebra](https://grass.osgeo.org/grass-stable/manuals/t.rast.algebra.html) manual for further details.\n\n#### Number of consecutive days with LSTmean <= -10.0\n\n::: {.cell execution_count=53}\n``` {.python .cell-code}\n# Create annual mask\ngs.run_command(\"t.rast.aggregate\",\n               input=\"lst_daily\",\n               output=\"annual_mask\",\n               basename=\"annual_mask\",\n               suffix=\"gran\",\n               granularity=\"1 year\",\n               method=\"count\")\n```\n:::\n\n\n::: {.cell execution_count=54}\n``` {.python .cell-code}\n# Replace values by zero\nexpression=\"if(annual_mask, 0)\"\n\ngs.run_command(\"t.rast.mapcalc\",\n               input=\"annual_mask\",\n               output=\"annual_mask_0\",\n               expression=expression,\n               basename=\"annual_mask_0\")\n```\n:::\n\n\n::: {.cell execution_count=55}\n``` {.python .cell-code}\n# Calculate consecutive days with LST <= -10.0\nexpression=\"lower_m2_consec_days = annual_mask_0 {+,contains,l} if(lst_daily <= -10.0 && lst_daily[-1] <= -10.0 || lst_daily[1] <= -10.0 && lst_daily <= -10.0, 1, 0)\"\n\ngs.run_command(\"t.rast.algebra\",\n               expression=expression,\n               basename=\"lower_m2_\",\n               suffix=\"gran\",\n               nproc=7)\n```\n:::\n\n\n::: {.cell execution_count=56}\n``` {.python .cell-code}\n# Inspect values\ngs.run_command(\"t.rast.list\",\n               input=\"lower_m2_consec_days\",\n               columns=\"name,start_time,min,max\")\n```\n:::\n\n\n::: {.cell execution_count=57}\n``` {.python .cell-code}\n# Median number of consecutive days with LST <= -2\ngs.run_command(\"t.rast.series\",\n               input=\"lower_m2_consec_days\",\n               output=\"median_lower_m2_consec_days\",\n               method=\"median\")\n```\n:::\n\n\n::: {.cell execution_count=58}\n``` {.python .cell-code}\n# Display raster map with interactive class\nlt2_map = gj.InteractiveMap(width = 500, use_region=True, tiles=\"OpenStreetMap\")\nlt2_map.add_raster(\"median_lower_m2_consec_days\")\nlt2_map.add_layer_control(position = \"bottomright\")\nlt2_map.show()\n```\n:::\n\n\nWe have now derived many potentially relevant predictors for the mosquito habitat suitability and we could still derive some more, for example, the number of mosquito or virus cycles per year based on development temperature thresholds and growing degree days (GDD). This could be achieved with [t.rast.accumulate](https://grass.osgeo.org/grass-stable/manuals/t.rast.accumulate.html) and [t.rast.accdetect](https://grass.osgeo.org/grass-stable/manuals/t.rast.accdetect.html). \n\nWe will now close this session as we will open it again from R in the last part of this session.\n\n::: {.cell execution_count=59}\n``` {.python .cell-code}\nsession.finish\n```\n:::\n\n\n",
    "supporting": [
      "notebook_ex_rs_grass_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}